<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><meta name="renderer" content="webkit"><meta name="description" content="yay!"><link rel="icon" href="/favicon.ico"><title>2014-10-22-js-regex-g-flag-and-performance</title><link rel="stylesheet" href="../resource/css/typo.css"><link rel="stylesheet" href="../resource/css/style.css"></head><body><div class="container"><div class="article"><h1 id="-js-lastindex">简单的js正则表达式的性能测试和lastIndex</h1>
<p>最近用到js做一些文本处理，免不了涉及正则表达式，由于文本的规模会达到GB级，速度和还是很关键的。</p>
<p>根据 <a href="http://jsperf.com/regexp-test-search-vs-indexof/12">jsperf</a> 上的测试发现，如果需要用到正则去匹配的话，还是预编译的表达式<code>precompiled search</code>表现最好。这是一个比较容易也比较重要的优化项。</p>
<p>看MDN发现有一个<code>g flag</code>代表global match也就是尝试所有可能的匹配。MDN上的相关解释如下。</p>
<blockquote>
<p>Whether to test the regular expression against all possible matches in a string, or only against the first.</p>
</blockquote>
<p>所有的又产生了一个疑问，如果我这需要判断是否存在一个表达式，不需要知道几个，也就是只用<code>RegExp.test()</code>，需不需要<code>g flag</code>，感觉加上有可能会使速度变慢，但是不确定，写了一个很简陋的性能测试。</p>
<pre><code class="lang-javascript">var start = +new Date(),
    end,
    globalRegex = /someone/g,
    nonGlobalRegex = /someone/,
    testStr = &#39;This optimization makes the lexer more than twice as fast! Why does this make sense? First, if you think about it in the simplest way possible, the iteration over rules moved from Python code to C code (the implementation of the re module). Second, its even more than that. In the regex engine, | alternation doesnt simply mean iteration. When the regex is built, all the sub-regexes get combined into a single NFA - some states may be combined, etc. In short, the speedup is not surprising.someone&#39;;

for (var i = 100000; i &gt;= 0; i--) {
  // with a g flag
  globalRegex.test(testStr);

  // without g flag
  // nonGlobalRegex.test(testStr);
}
end = +new Date();

console.log(end - start);
</code></pre>
<p>分别去掉注释分别运行发现带<code>g flag</code>的需要25-30ms，而不带<code>g flag</code>的却需要40+ms，和直觉相反。然后回想了一下<code>g flag</code>的作用，接着看文档，发现一个叫做<code>lastIndex</code>的属性：</p>
<blockquote>
<p>The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.</p>
</blockquote>
<p>得知既然是尝试匹配所有可能，如果没有主动把<code>lastIndex</code>清零，则会继续上一次的匹配知道结束。所以以上代码如果是带<code>g flag</code>的情况上一次匹配完成，已经到了句末，加入此时<code>console.log(globalRegex.lastIndex)</code>会得到<code>testStr.length</code>，而且下一次会继续尝试向后匹配，并另计返回false。所以可以理解上述的时间差。</p>
<p>假如把for循环中带<code>g flag</code>的情况加一句：</p>
<pre><code class="lang-javascript">for (var i = 100000; i &gt;= 0; i--) {
  // with a g flag
  globalRegex.test(testStr);
  globalRegex.lastIndex = 0;

  // without g flag
  // nonGlobalRegex.test(testStr);
}
</code></pre>
<p>两种情况的运行结果都在40+ms。</p>
<p><strong>结论：即使加上<code>g flag</code>理论上也不影响速度，只需要将<code>lastIndex</code>清零，不过清零还是需要消耗的，所以如果只需要匹配判断，可以不用<code>g flag</code></strong></p>
</div></div><footer><a href="../" class="links">Home</a><a href="https://github.com/zhulongzheng" target="_blank" class="links">Link</a><a href="mailto:zhulongzheng@gmail.com" class="links">Contact</a></footer></body></html>
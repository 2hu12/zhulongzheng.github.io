<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><meta name="renderer" content="webkit"><meta name="description" content="yay!"><link rel="icon" href="/favicon.ico"><title>2014-10-30-利用原生-Javascript-实现-Delegated-Event</title><link rel="stylesheet" href="../resource/css/typo.css"><link rel="stylesheet" href="../resource/css/style.css"></head><body><div class="container"><h1 id="-javascript-delegated-event">利用原生 Javascript 实现 Delegated Event</h1>
<p>想要实现类似于 jQuery 中类似于 <code>.on()</code> 中的 Delegated Event，却又不想用 jQuery 怎么破？</p>
<h3 id="-"><strong>先看问题</strong></h3>
<p>举个例子说明一下，有一组按钮，每当点击其中一个按钮，就把这个按钮的状态变为 &quot;active&quot;，再点一下就取消 &quot;active&quot; 状态，代码如下：</p>
<pre><code class="lang-html">&lt;ul class=&quot;toolbar&quot;&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;Pencil&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;Pen&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;Eraser&lt;/button&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>用最普通的 js 可以这样处理：</p>
<pre><code class="lang-javascript">var buttons = document.querySelectorAll(&quot;.toolbar .btn&quot;);

for(var i = 0; i &lt; buttons.length; i++) {
  var button = buttons[i];
  button.addEventListener(&quot;click&quot;, function() {
    if(!button.classList.contains(&quot;active&quot;))
      button.classList.add(&quot;active&quot;);
    else
      button.classList.remove(&quot;active&quot;);
  });
}
</code></pre>
<p>不过并没有达到预期的效果。</p>
<h3 id="-"><strong>闭包惹的祸</strong></h3>
<p>有经验的读者可能已经看出不对劲的地方了。那是因为处理点击事件的 handler 函数形成独立的作用域，是其中的 <code>button</code> 会尝试去更上级的作用域去寻找。
不过真正当你去点击按钮的时候，循环已经完成，<code>button</code> 就会一直指向最后一个按钮，所以效果就是不管点击哪个按钮都是最后一个按钮的状态在变化。</p>
<p>把代码改善一下：</p>
<pre><code class="lang-javascript">var buttons = document.querySelectorAll(&quot;.toolbar button&quot;);
var createToolbarButtonHandler = function(button) {
  return function() {
    if(!button.classList.contains(&quot;active&quot;))
      button.classList.add(&quot;active&quot;);
    else
      button.classList.remove(&quot;active&quot;);
  };
};

for(var i = 0; i &lt; buttons.length; i++) {
  button.addEventListener(&quot;click&quot;, createToolBarButtonHandler(buttons[i]));
}
</code></pre>
<p>好了，现在就满足要求了。</p>
<h3 id="-"><strong>不过。。。</strong></h3>
<p>虽然可以勉强使用，但还可以做地更好一些。</p>
<p>首先上面的代码会产生许多 handler，在只有三个按钮的时候还是可以接受的。</p>
<p>不过当有上千个按钮需要监听点击事件的情况：</p>
<pre><code class="lang-html">&lt;ul class=&quot;toolbar&quot;&gt;
  &lt;li&gt;&lt;button id=&quot;button_0001&quot;&gt;Foo&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button id=&quot;button_0002&quot;&gt;Bar&lt;/button&gt;&lt;/li&gt;
  // ... 997 more elements ...
  &lt;li&gt;&lt;button id=&quot;button_1000&quot;&gt;baz&lt;/button&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>就没那么轻松了，虽说不会崩溃，但这种方式非常不理想。上面的实现方式是绑定了好多不同的却功能相似的函数，其实根本不需要这样。只需要绑定一个共享的函数就够了。</p>
<p>改动很简单，可以使用对应的事件对象作为 handler 的参数，就可以通过<code>event.currentTarget</code>很方便地找到对应点击的按钮了。</p>
<blockquote>
<p>译者注：这里的 <code>event.currentTarget</code> 也就相当于 handler 中的 <code>this</code>。</p>
</blockquote>
<pre><code class="lang-javascript">var buttons = document.querySelectorAll(&quot;.toolbar button&quot;);

var toolbarButtonHandler = function(e) {
  var button = e.currentTarget;
  if(!button.classList.contains(&quot;active&quot;))
    button.classList.add(&quot;active&quot;);
  else
    button.classList.remove(&quot;active&quot;);
};

for(var i = 0; i &lt; buttons.length; i++) {
  button.addEventListener(&quot;click&quot;, toolbarButtonHandler);
}
</code></pre>
<p>到此我们的确实现了绑定同一个 handler，而且增加了代码的可读性。</p>
<p>不过还可以做的更好。</p>
<p>假设这样一种场景，按钮组中会动态的添加新的按钮进来，这样就还得在新添加的按钮上绑定监听处理。这就有点麻烦了。</p>
<p>不如换一种方法。</p>
<p>先回想一下 DOM 中 event 的工作原理。</p>
<h3 id="-dom-event-"><strong>DOM Event 的工作原理简析</strong></h3>
<p>当点击一个元素，会产生一个点击事件，这个事件分为三个阶段。</p>
<ul>
<li>Capturing 捕获阶段</li>
<li>Target 目标阶段</li>
<li>Bubbling 冒泡阶段</li>
</ul>
<!-- > NOTE: Not all events bubble/capture, instead they are dispatched directly on the target, but most do.
The event starts outside the document and then descends through the DOM hierarchy to the target of the event. Once the event reaches it's target, it then turns around and heads back out the same way, until it exits the DOM. -->
<blockquote>
<p>&quot;
注：虽然并不是所有事件的都有 冒泡/捕获 阶段，但绝大部分都有。捕获阶段是从最外层的 document 开始，穿过目标元素的祖先元素，到达目标元素，然后再原路冒泡回到 document。
&quot;</p>
</blockquote>
<p>从一段 HTML 代码的例子来看:</p>
<pre><code class="lang-html">&lt;html&gt;
&lt;body&gt;
  &lt;ul&gt;
    &lt;li id=&quot;li_1&quot;&gt;&lt;button id=&quot;button_1&quot;&gt;Button A&lt;/button&gt;&lt;/li&gt;
    &lt;li id=&quot;li_2&quot;&gt;&lt;button id=&quot;button_2&quot;&gt;Button B&lt;/button&gt;&lt;/li&gt;
    &lt;li id=&quot;li_3&quot;&gt;&lt;button id=&quot;button_3&quot;&gt;Button C&lt;/button&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果点击 Button A 按钮，事件的过程是这样的：</p>
<pre><code>START
| #document  \
| HTML        |
| BODY         } CAPTURE PHASE
| UL          |
| LI#li_1    /
| BUTTON     &lt;-- TARGET PHASE
| LI#li_1    \
| UL          |
| BODY         } BUBBLING PHASE
| HTML        |
| #document  /
V
END
</code></pre><p>我们可以注意到在事件的冒泡阶段，按钮的祖先元素 <code>ul</code> 也可以收到点击事件。我们可以利用这个现象和已知元素的层级简化代码，实现 Delegated Events。</p>
<h3 id="-delegated-events-"><strong>Delegated Events</strong></h3>
<p>Delegated Events 是把事件处理绑定在真正需要被绑定元素的祖先元素上，然后通过一定的条件筛选出真正需要被绑定的元素。</p>
<p>还是最初的代码：</p>
<pre><code class="lang-html">&lt;ul class=&quot;toolbar&quot;&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;Pencil&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;Pen&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;Eraser&lt;/button&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>既然每次事件冒泡的阶段 <code>ul.toolbar</code> 也可以收到点击事件，我们就把事件绑定在它上面。修改对应的 js 代码：</p>
<pre><code class="lang-javascript">var toolbar = document.querySelectorAll(&quot;.toolbar&quot;);
toolbar.addEventListener(&quot;click&quot;, function(e) {
  var button = e.target;
  if(!button.classList.contains(&quot;active&quot;))
    button.classList.add(&quot;active&quot;);
  else
    button.classList.remove(&quot;active&quot;);
});
</code></pre>
<p>That cleaned up a lot of code, and we have no more loops! Notice that we use e.target instead of e.currentTarget as we did before. That is because we are listening for the event at a different level.
去掉了 for 循环使代码看起来清爽多了。注意这次用的是 <code>e.target</code> 而非 <code>e.currentTarget</code>。</p>
<ul>
<li>e.target 是事件的目标元素，也就是例子的 button.btn</li>
<li>e.currentTarget 是被绑定事件处理的元素，也就是例子中的 ul.toolbar</li>
</ul>
<h3 id="-more-robust-delegated-events-"><strong>More Robust Delegated Events</strong></h3>
<p>现在已经可以处理所有 ul.toolbar 后代元素的点击事件，不过这样有些太简单了，我们需要过滤掉不能被点击的后代元素：</p>
<pre><code>&lt;ul class=&quot;toolbar&quot;&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;&lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; Pencil&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;&lt;i class=&quot;fa fa-paint-brush&quot;&gt;&lt;/i&gt; Pen&lt;/button&gt;&lt;/li&gt;
  &lt;li class=&quot;separator&quot;&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button class=&quot;btn&quot;&gt;&lt;i class=&quot;fa fa-eraser&quot;&gt;&lt;/i&gt; Eraser&lt;/button&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>我们并不需要处理对 li.separator 的点击事件，那就加一个过滤辅助函数：</p>
<pre><code class="lang-javascript">var delegate = function(criteria, listener) {
  return function(e) {
    var el = e.target;
    do {
      if (!criteria(el)) continue;
      e.delegateTarget = el;
      listener.apply(this, arguments);
      return;
    } while( (el = el.parentNode) );
  };
};
</code></pre>
<p>这个过滤辅助函数的作用，一是判断 e.target 和它的所有祖先元素是否满足过滤条件。如果满足就在事件对象上增加一个 delegateTarget 属性，用于后面使用，然后调用事件的处理函数。如果一路检查所有祖先元素，都不符合条件则不触发处理函数。</p>
<p>具体使用：</p>
<pre><code class="lang-javascript">var toolbar = document.querySelectorAll(&quot;.toolbar&quot;);
var buttonsFilter = function(elem) { return elem.classList &amp;&amp; elem.classList.contains(&quot;btn&quot;); };
var buttonHandler = function(e) {
  var button = e.delegateTarget;
  if(!button.classList.contains(&quot;active&quot;))
    button.classList.add(&quot;active&quot;);
  else
    button.classList.remove(&quot;active&quot;);
};
toolbar.addEventListener(&quot;click&quot;, delegate(buttonsFilter, buttonHandler));
</code></pre>
<p>没错！就是这个意思。只需要在一个元素上绑定一个 handler，就够了。并且也不需要担心动态增加的元素。这就是所谓的 Delegated Events。</p>
<h3 id="-wrapping-up-"><strong>Wrapping up</strong></h3>
<p>上面已经实现了在不使用 jQuery 的情况下实现 Delegated Events。</p>
<p>还可以把代码进一步封装一下：</p>
<ul>
<li>Create helper functions to handle criteria matching in a unified functional way. Something like:</li>
</ul>
<pre><code class="lang-javascript">var criteria = {
  isElement: function(e) { return e instanceof HTMLElement; },
  hasClass: function(cls) {
    return function(e) {
      return criteria.isElement(e) &amp;&amp; e.classList.contains(cls);
    }
  }
  // More criteria matchers
};
</code></pre>
<ul>
<li>A partial application helper would also be nice:</li>
</ul>
<pre><code class="lang-javascript">var partialDelgate = function(criteria) {
  return function(handler) {
    return delgate(criteria, handler);
  }
};
</code></pre>
<p><a href="http://codepen.io/32bitkid/blog/understanding-delegated-javascript-events">原文链接</a></p>
</div><footer><a href="../" class="links">Home</a><a href="https://github.com/zhulongzheng" target="_blank" class="links">Link</a><a href="mailto:zhulongzheng@gmail.com" class="links">Contact</a></footer></body></html>